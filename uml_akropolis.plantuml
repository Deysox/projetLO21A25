
@startuml

namespace Barnabe {

    package Utilitaires #DDDDDD {
        class Rotation {
            - r : int
            + Rotation(int)
            + value() : int {const}
            + operator+(const Rotation&) : Rotation {const}
            + operator-(const Rotation&) : Rotation {const}
            + operator++() : Rotation&
            + operator++(int) : Rotation
            + operator==(const Rotation&) : bool {const}
            + operator!=(const Rotation&) : bool {const}

        }

        class Position {
            - posX : int
            - posY : int
            + Position(int, int)
            + x() : int {const}
            + y() : int {const}
            + operator+(const Position&) : Position {const}
            + operator+(const Rotation&) : Position {const}
            + operator-(const Position&) : Position {const}
            + operator==(const Position&) : bool {const}
            + operator!=(const Position&) : bool {const}
            + isNeighbour(const Position&) : bool {const}
            + class iterator
            + begin() : iterator {const}
            + end() : iterator {const}
            + cbegin() : iterator {const}
            + cend() : iterator {const}
            + toString() : string {const}

        }


        struct PositionHasher {
            operator()(const Position&) : size_t {const}
        }
    }



    package "Gestion Plateau" #ffeeee {
        class Cell {
            - id : int
            - color : Color
            - type : Type
            + Cell(int, Color, Type)
            + Cell(const Cell&)
            + ~Cell() {virtual}
            + getColor() : Color {const}
            + getEffectiveColor(const Rotation&) : Color {const} {virtual}
            + getType() : Color {const}
            + getID() : id {const}
            + displayTop(unsigned int) : string const {virtual}
            + displayBottom() : string {const} {virtual}
        }

        class BicolorCell {
           - secondaryColor : Color
           - rotation : Rotation
           + BicolorCell(int, Color, Type, Color, Rotation)
           + BicolorCell(const BicolorCell&)
           + getSecondaryColor() : Color {const}
           + getRotation() : Rotation {const}
           + setRotation(const Rotation&)
        }

        BicolorCell --|> Cell
        BicolorCell "*" o-- "1" Rotation

        abstract Tile {
           # {static} id : int
           # cells : vector<const Cell*>*
           + Tile()
           + ~Tile()
           + getSize() : unsigned int {const}
           + getCell(int) : const Cell* {const}
           + {abstract} calculatePositions(const Position&, Rotation&) : vector<Position>
           + class const_iterator
           + begin() : const_iterator {const}
           + end() : const_iterator {const}
           + cbegin() : const_iterator {const}
           + cend() : const_iterator {const}
        }

        class StartingTile {
            + StartingTile()
            + calculatePositions(const Position&, Rotation&) : vector<Position> {override}
        }
        class ClassicTile {
            + ClassicTile(Color, Type, Color, Type, Color, Type)
            + calculatePositions(const Position&, Rotation&) : vector<Position> {override}
        }
        class AthenaTile {
            - BicolorCell* cell;
            + AthenaTile(Color, Color, Type)
            + calculatePositions(const Position&, Rotation&) : vector<Position> {override}
        }

        StartingTile --|> Tile
        ClassicTile --|> Tile
        AthenaTile --|> Tile

        Tile "1" *-- "1.." Cell


        together {
          class Board {
              {static} - stringToColor : map<string, Color>
              {static} - stringToType : map<string, Type>
              {static} - colorToString : map<Color, string>
              {static} - typeToString : map<Type, string>
              - cells : unordered_map<Position, pair<const Cell*, unsigned int>, PositionHasher>
              - corner_tl : Position
              - corner_bl : Position
              + Board()
              + ~Board()
              + Board(const Board&)
              + operator=(const Board&) : Board&
              + getCell(const Position&) : const Cell* {const}
              + getCell(int, int) : const Cell* {const}
              + getHeight(const Position&) : unsigned int {const}
              + getHeight(int, int) : unsigned int {const}
              + setCell(const Position&, unsigned int, const Cell*)
              + setCell(int, int, unsigned int, const Cell*)
              + getCorners() : pair<Position, Position> {const}
              + class iterator
              + class const_iterator
              + begin() : iterator
              + end() : iterator
              + begin() : const_iterator {const}
              + end() : const_iterator {const}
              + cbegin() : const_iterator {const}
              + cend() : const_iterator {const}
              + toJsonBoard() : json {const}
              {static} + fromJsonBoard(const json&) : Board

          }

          Board "*" o-- "*" Cell
          Board "0..1" o-- "*" Position
          Board "1" *-- "1" PositionHasher

          class BoardManager {
              - board : Board*
              - startingTile : StartingTile*
              + BoardManager()
              + ~BoardManager()
              + BoardManager(const BoardManager&)
              + BoardManager(const Board& b)
              + operator=(const BoardManager&) : BoardManager&
              + getBoard() : const Board* {const}
              + setBoard(const BoardManager& bm)
              + place(const Tile*, Position, Rotation, bool) : int
          }

          BoardManager "1" *-- "1" Board
          BoardManager "1" *-- "1" StartingTile
        }
    }


    enum Color {
        BLUE
        RED
        YELLOW
        GREEN
        PURPLE
    }

    enum Type {
        DISTRICT
        PLACE
        QUARRY
    }

    Color -- Cell
    Type -- Cell


    package QT #eeffee {
        abstract ContainerQt <typename Container_Type \n typename Item> {
            # size : int
            # cells : Container_Type
            # item : Item
            + ContainerQt(QWidget*, int)
            + updateDisplay()
            # {abstract} draw()
            # {abstract} empty()
            + setItem(const Item*) {virtual}
            + getItem() : const Item* {const} {virtual}
        }

        ContainerQt "1" *-- "*" CellQt

        abstract CellQt {
            # size : int
            # w : int
            # h : int
            # pos : Position
            # locked : bool
            + CellQt(QWidget*, const Position&, bool, int)
            + paintEvent(QPaintEvent*) {override}
            {abstract} # brush() : QBrush {const}
            {abstract} # pen() : QPen {const}
            {abstract} # endPaintEventActions()
            + lock()
            + unlock()

        }

        class CellQtFull {
            {static} - colors : map<Color, pair<QColor, QColor>>
            {static} - colorText : map<Color, string>
            {static} - placeText : map<Color, string>
            - color : Color
            - type : Type
            - height : unsigned int
            - label : QLabel*
            + CellQtFull(Qwidget*, const Position&, bool, int, Color, Type, unsigned int)
            # brush() : QBrush {const} {override}
            # pen() : QPen {const} {override}
            # endPaintEventActions() {override}

        }

        Color -- CellQtFull
        Type -- CellQtFull

        CellQtFull --|> CellQt

        class CellQtEmpty {
            + CellQtEmpty(QWidget*, const Position&, bool, int)
            # brush() : QBrush {const} {override}
            # pen() : QPen {const} {override}
            # endPaintEventActions() {override}
        }

        CellQtEmpty --|> CellQt

        abstract TileQt {
            + TileQt(QWidget*, const Tile*, int)
            + empty() {override}
        }

        TileQt --|> ContainerQt : "ContainerQt<vector<CellQt*>,Tile>"
        TileQt "*" o-- "1" Tile

        class ClassicTileQt {
            +ClassicTileQt(QWidget*, const ClassicTile*, int)
            +setItem(const ClassicTile*) {override}
            #draw() {override}
        }

        ClassicTileQt "*" o-- "1" ClassicTile
        ClassicTileQt --|> TileQt


        class BoardQt {
            + BoardQt(QWidget*, const Board*, int)
            + empty()  {override}
            + draw() {override}
            + lock()
            + unlock()
        }

        BoardQt --|> ContainerQt : "ContainerQt<unordered_map<Position,CellQt*>,Board, PositionHasher>"
        BoardQt "*" o-- "1" Board
        BoardQt "0..1" *-- "*" Position
        BoardQt "1" *-- "1" PositionHasher

    }

}

namespace Amalena {
    class River{
        - tiles : vector<Tile*>
        - pile : Pile&
        - max_tiles : int
        - fillriver() : void
        + River(nb :size_t, pile : Pile&)
        + River(tiles : vector<Tile*>, nb :size_t, pile : Pile&)
        + operator=(f : River&)
        + River (r : const River&)
        + ~River()
        + River (r : const River&)
        + operator= (f: const River&)
        + getPosition(t : const Tile*)  : size_t {const}
        + giveTile (position : size_t){const}
        + stay1() : bool {const}
        + toString() {const}
        + getSize() : size_t {const}
        + getTiles() : vector<Tile*> {const}
        + addTilesInriver(tile : Tile*) : void
        + clearVectorRiver() : void
        + begin() :RiverIterator
        + end() : RiverIterator




    }
    River o-- "1..*" Tile
    class Pile{
        - tiles : vector<Tile*>
        - deck : Deck&
        +Pile (d:Deck)
        + Pile (d: Deck, t: vector<Tile*>)
        +~Pile()
        + isempty() : bool {const}
        + Draw() :Tile*
        +operator=(p : const Pile&)
        + void addTilesInPile(tile: Tile*)
        + void clearVectorPile()
        + begin() PileIterator
        + end() PileIterator

    }
    Pile o-- "1..*" Tile
     package QT #eeffee {
    class RiverQT{
    - river : River&
    +riverQT (parent : QWidget*, r : River&)
    + ~riverQT()
    +updateDisplay() : void
    }
    }
    RiverQT o-- "1--1" River
}

namespace Eloise {

    abstract Game {
        # players : vector<Player*>
        # current_player : size_t
        # nb_players : size_t
        # {static} nb_players_max : size_t
        # deck : Deck*
        # pile : Amalena::Pile*
        # river : Amalena::River*
        # variant : string
        # isSolo : bool
        # difficulty : int
        # Game(nb_players: size_t, variant: string)
        # Game(game_memento: Amalena::GameMemento)
        # ~Game()
        + setVariant(v: string)
        + getVariant() : string {const}
        + setSolo(solo: bool)
        + isGameSolo() : bool {const}
        + setDifficulty(dif: int)
        + getDifficulty() : int {const}
        + getNbPlayers() : size_t {const}
        + static getNbPlayersMax() : size_t
        + getCurrentPlayer() : size_t {const}
        + getPlayer(position: size_t) : Player*
        + displayPlayers()
        + nextPlayer()
        + manageGame()
        + manageSoloGame(difficulty: int)
        + pickRiver() : Tile&
        + endGame()
        + abandonGame()
        + manageResumeGame()
        {abstract} # addPlayer(name: string)
        {abstract} # addEachPlayerToGame()
        {abstract} # displayCurrentPlayerInfo()
        {abstract} # actionsPlayer(river_copy: Amalena::River*, board_copy: BoardManager*) : bool
        {abstract} # askNameSoloGame()
        {abstract} # architectCreation(difficulty: int)
        {abstract} # architectPlaySoloGame()
        {abstract} # realPlayerPlaySoloGame(board_copy: BoardManager*, river_copy: Amalena::River*) : bool
        {abstract} # chooseTileRiver() : Tile&
        {abstract} # displayRiver()
        {abstract} # displayAbandonGame1() : string
        {abstract} # displayAbandonGame2()
    }

    Game *-- "1" River
    Game *-- "1" Deck
    Game *-- "1" Pile
    Game *-- "*" Player

    class GameConsole {
        - {static} instanceConsole : GameConsole*
        - GameConsole(nb_players: size_t, v: string)
        - GameConsole(game_memento: Amalena::GameMemento)
        + static giveInstance(nb_players: size_t, v: string) : GameConsole&
        + static giveInstance(game_memento: Amalena::GameMemento) : GameConsole&
        + static freeInstance()
        + addPlayer(name: string)
        + addEachPlayerToGame()
        + displayCurrentPlayerInfo()
        + actionsPlayer(river_copy: Amalena::River*, board_copy: BoardManager*) : bool
        + askNameSoloGame()
        + architectCreation(difficulty: int)
        + architectPlaySoloGame()
        + realPlayerPlaySoloGame(board_copy: BoardManager*, river_copy: Amalena::River*) : bool
        + displayRiver()
        + chooseTileRiver() : Tile&
        + displayAbandonGame1() : string
        + displayAbandonGame2()
    }

    Game <|-- GameConsole

    class GameQt {
        - parent : QWidget*
        - riverWindow : Amalena::riverQT*
        - {static} instanceQt : GameQt*
        - GameQt(nb_players: size_t, v: string)
        - GameQt(game_memento: Amalena::GameMemento)
        + {static} giveInstance(nb_players: size_t, v: string) : GameQt&
        + {static} giveInstance(game_memento: Amalena::GameMemento) : GameQt&
        + {static} freeInstance()
        + addPlayer(name: string)
        + addEachPlayerToGame()
        + displayCurrentPlayerInfo()
        + actionsPlayer(river_copy: Amalena::River*, board_copy: BoardManager*) : bool
        + askNameSoloGame()
        + architectCreation(difficulty: int)
        + architectPlaySoloGame()
        + realPlayerPlaySoloGame(board_copy: BoardManager*, river_copy: Amalena::River*) : bool
        + displayRiver()
        + chooseTileRiver() : Tile&
        + displayAbandonGame1() : string
        + displayAbandonGame2()
    }

    Game <|-- GameQt

    abstract Player {
        # {static} stones_distribution : size_t
        # name : string
        # board : BoardManager
        # stones : int
        + Player(s: string)
        + virtual ~Player()
        + getName() : string {const}
        + getStones() : int
        + getBoard() : BoardManager {const}
        + setBoard(b: BoardManager)
        + setStones(n: int)
        + addStones(n: int)
        + virtual playTurn(tile: Tile)
        {abstract} # displayBoard()
        {abstract} # placeTile(tile: Tile)
    }

    Player *-- "1" Boardmanager

    class PlayerQt {
        + BoardWidget : BoardQt*
        + window : QWidget*
        + PlayerQt(s: string, parent: QObject*)
        + displayBoard()
        + placeTile(tile: Tile)
    }

    Player <|-- PlayerQt

    class ArchitectQt {
        - difficulty : int
        - architect_tiles : vector<Tile*>
        + ArchitectQt(name: string, d: int, parent: QObject*)
        + playTurn(t: Tile)
    }

    PlayerQt <|-- ArchitectQt

    class PlayerConsole {
        + PlayerConsole(s: string)
        + displayBoard()
        + placeTile(tile: Tile)
     }

     Player <|-- PlayerConsole

    class ArchitectConsole {
        - difficulty : int
        - architect_tiles : vector<Tile*>
        + ArchitectConsole(name: string, d: int)
        + playTurn(t: Tile)
    }

    PlayerConsole <|-- ArchitectConsole

    class Menu{
        + Menu()
        + display()
    }

    Menu *-- "1" Game

    class MenuQt{
        - boutonLancerGame : QPushButton*
        - boutonReprendreGame : QPushButton*
        - boutonAfficherRegles : QPushButton*
        + MenuQt(parent: QWidget*)
        - boutonLancerGameClique()
        - boutonReprendreGameClique()
        - boutonAfficherReglesClique()
    }

    MenuQt *-- "1" Game

    class Deck {
       + {static} stringToColor : map<string, Color>
       + {static} stringToType : map<string, Color>
       - tiles : vector<ClassicTile*>
       + Deck()
       + getTiles() : vector<ClassicTile*> {const}
       + operator=(f: Deck) : Deck
       + ~Deck()
    }

    Deck *-- "*" Tile

}

namespace Marilou {

    struct ScoreVariants {
        + habitations : bool
        + marches : bool
        + casernes : bool
        + temples : boolclass
        + jardins : bool
    }

    abstract class Score {
        + compute(player : Eloise::Player, variants : ScoreVariants) : int
    }

    class ScorePierre {
        + compute(player : Eloise::Player, variants : ScoreVariants) : int
    }

    abstract class ScoreCouleur {
        + compute(player : Eloise::Player, variants : ScoreVariants) : int
    }

    class ScoreBleu {
        + compute(player : Eloise::Player, variants : ScoreVariants) : int
    }

    class ScoreJaune {
        + compute(player : Eloise::Player, variants : ScoreVariants) : int
    }

    class ScoreRouge {
        + compute(player : Eloise::Player, variants : ScoreVariants) : int
    }

    class ScoreViolet {
        + compute(player : Eloise::Player, variants : ScoreVariants) : int
    }

    class ScoreVert {
        + compute(player : Eloise::Player, variants : ScoreVariants) : int
    }

    class ScoreGeneral {
        - couleurs : List<ScoreCouleur*>
        - scorePierre : ScorePierre
        + ScoreGeneral()
        + compute(player : Eloise::Player, variants : ScoreVariants) : int
    }

    Score <|-- ScorePierre
    Score <|-- ScoreCouleur
    Score <|-- ScoreGeneral

    ScoreCouleur <|-- ScoreBleu
    ScoreCouleur <|-- ScoreJaune
    ScoreCouleur <|-- ScoreRouge
    ScoreCouleur <|-- ScoreViolet
    ScoreCouleur <|-- ScoreVert

    ScoreGeneral o-- ScoreCouleur
    ScoreGeneral o-- ScorePierre
}

Marilou.Score ..> Eloise.Player

namespace Amal√©na{



class  GameMemento{
- game_id : string
- version : sting
- riverid : vector<int>
- pileid vector<int>
- PlayersName :vector<string>
- PlayersStone :vector<int>
- boards :json
- nbplayer : size_t
- currentplayer : size_t
- variante : string

+ GameMemento(gameid : string,version : string, riverid : vector<int>, pileid: vector<int>,playersName :vector<string>,PlayersStone : vector<int> boards, nbplayer : size_t,
currentplayer : size_t, variante : string, boards : json)
+ GameMemento()
+~GameMemento()

+get_version(): string {const}
+ set_version(version : const string&)

+get_riverid() : vector<int> {const}
+ set_riverid( riverid : const vector<int>)

+get_pileid(): vector<int> {const}
+ set_pileid(pileid const vector<int>)


+ get_players_name() : vector<string>
+ set_players_name(playersName : vector<string>) : void

+ get_players_stone() : vector<int>
+set_players_stone(playersStone : vector<int>) : void

+get_boards() : json
+ set_boards(boards : json) : void

+get_nbplayer() : size_t
+set_nbplayer(nbplayers : size_t) : void

+ get_currentplayer() : size_t
+set_currentplayer(currentplayer : size_t) : void

+get_variante() : string
+set_variante(variante : string) : void

+ get_game_id (game_id : const string)
}


class SaveManager{
- gameMemento : GameMemento*
+ savemanager(g : GameMemento*)
+ savemanager()
+ savemanager( s: const savemanager&)
+ ~savemanager()
+ operator= (s: const savemanager&))
+ void save()
+ void restore (game_id : string)
+ fromjson(json data) : void
+ tojson(): json
}

SaveManager *-- "1" GameMemento
Game *-- "1" GameMemento
Menu *-- "1" SaveManager
Game *-- "1" SaveManager

}

@enduml